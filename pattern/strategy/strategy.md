<h1>Стратегия</h1>
  <p>
    Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс,
    после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
  </p>
  <p>Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.</p>
  <p>
    Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы.
    Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.
  </p>
  <h2>Применимость</h2>
  <ul>
    <li>
      Когда нужно использовать разные вариации какого-то алгоритма внутри одного объекта
    </li>
    <li>
      <p>
        Когда есть множество похожих классов, отличающихся только некоторым поведением
      </p>
    </li>
    <li>
      Чтобы не обнажать детали реализации алгоритмов для других классов
    </li>
  </ul>
  <h2>Плюсы и минусы</h2>
    <ul>
      <b>Плюсы</b>
      <li>Горячая замена алгоритмов на лету</li>
      <li>Изолирует код и данные алгоритмов от остальных классов</li>
      <li>Уход от наследования к делегированию</li>
      <li>Реализует принцип открытости/закрытости</li>
      </br>
      <b>Минусы</b>
      <li>Усложняет программу за счёт дополнительных классов</li>
      <li>Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую</li>
    </ul>
  <h2>Реальные примеры</h2>
  <p>
    Представьте, что вы разрабатываете «In-Memory-Cache». Поскольку он находится внутри памяти, его размер ограничен.
    Как только он полностью заполнится, какие-то записи придется убрать для освобождения места.
    Эту функцию можно реализовать с помощью нескольких алгоритмов, самые популярные среди них:
  </p>
  <ul>
    <li>Наиболее давно использовавшиеся (Least Recently Used – LRU): убирает запись, которая использовалась наиболее давно.</li>
    <li>«Первым пришел, первым ушел» (First In, First Out — FIFO): убирает запись, которая была создана раньше остальных</li>
    <li>Наименее часто использовавшиеся (Least Frequently Used — LFU): убирает запись, которая использовалась наименее часто.</li>
  </ul>
  <p>
    Проблема заключается в том, чтобы отделить кэш от этих алгоритмов для возможности их замены «на ходу».
    Помимо этого, класс кэша не должен меняться при добавлении нового алгоритма.
  </p>
  <p>
   В такой ситуации нам поможет паттерн Стратегия. Он предполагает создание семейства алгоритмов, каждый из которых имеет свой класс.
    Все классы применяют одинаковый интерфейс, что делает алгоритмы взаимозаменяемыми внутри этого семейства. Назовем этот общий интерфейс <code>evictionAlgo</code>.
  </p>
  <p>
    Теперь основной класс нашего кэша будет включать в себя <code>evictionAlgo</code>. Вместо прямой реализации всех типов алгоритмов вытеснения внутри самого себя,
    наш класс будет передавать их в <code>evictionAlgo</code>. Поскольку это интерфейс, мы можем непосредственно во время выполнения программы менять алгоритм на LRU, FIFO, LFU без изменений в классе кэша.
  </p>
