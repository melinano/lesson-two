<h1>Посетитель</h1>
  <p>
    Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции,
    не изменяя классы объектов, над которыми эти операции могут выполняться.
  </p>
  <p>
    Паттерн Посетитель предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких классах.
    Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. Вместо этого вы будете передавать эти объекты в методы посетителя.
  </p>
  <p>
    Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.
  </p>
  <h2>Применимость</h2>
  <ul>
    <li>
      Когда нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
      Посетитель позволяет применять одну и ту же операцию к объектам различных классов.
    </li>
    <li>
      <p>
        Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, без «засорения» классов такими операциями.
      </p>
    </li>
    <li>
      Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
    </li>
  </ul>
  <h2>Плюсы и минусы</h2>
    <ul>
      <b>Плюсы</b>
      <li>Принцип открытости/закрытости. Вы можете ввести новое поведение, которое может работать с объектами различных классов, не изменяя эти классы.</li>
      <li>Принцип единой ответственности. В один класс можно поместить несколько версий одного и того же поведения.</li>
      <li>
        Объект-посетитель может накапливать полезную информацию при работе с различными объектами.
        Это может быть удобно, когда необходимо обойти некоторую сложную структуру объектов, например,
        дерево объектов, и применить посетителя к каждому объекту этой структуры.
      </li>
      </br>
      <b>Минусы</b>
      <li>Необходимо обновлять всех посетителей каждый раз, когда класс добавляется или удаляется из иерархии элементов.</li>
      <li> Visitors might lack the necessary access to the private fields and methods of the elements that they’re supposed to work with.</li>
    </ul>
  <h2>Реальные примеры</h2>
  <p>
    Паттерн Посетитель позволяет вам добавлять поведение в структуру без ее изменения.
    Представим, что вы разработчик библиотеки, которая содержит структуры разных фигур:
  </p>
  <ul>
    <li>Квадрат</li>
    <li>Круг</li>
    <li>Треугольник</li>
  </ul>
  <p>
    Структуры каждой из вышеназванных фигур реализуют общий интерфейс фигуры <code>shape.go</code>.
  </p>
  <p>
    Как только сотрудники в вашей компании начали использовать вашу замечательную библиотеку,
    вас засыпали просьбами добавить тот или иной функционал. Рассмотрим один из простейших вариантов:
    команда попросила вас добавить в структуру функцию <code>getArea</code>, возвращающую площадь фигуры.
  </p>
  <p>
     Возможный вариант — решить вышеуказанную проблему благодаря использованию паттерна Посетитель. Сперва мы определяем интерфейс посетителя следующим способом:
  </p>
  <p>
    <pre>
      <code>
type visitor interface {
  visitForSquare(square)
  visitForCircle(circle)
  visitForTriangle(triangle)
}
      </code>
    </pre>
  </p>
  <p>
    Функции <code>visitForSquare(square)</code>, <code>visitForCircle(circle)</code>, <code>visitForTriangle(triangle)</code>
    позволят нам добавлять функционал для квадратов, кругов и треугольников соответственно.
  </p>
  <p>
    Мы не можем оставить только один метод <code>visit(shape)</code> в интерфейсе посетителя.
    Это невозможно из-за того, что язык Go не поддерживает перегрузку методов, поэтому нельзя иметь методы с одинаковыми именами, но разными параметрами.
  </p>
  <p>
    
  </p>
    Второй, не менее важный, этап – добавление метода <code>accept</code> в интерфейс фигуры.
  <p>
    <pre>
      <code>
func accept(v visitor)
      </code>
    </pre>
  </p>
  <p>
    Все структуры фигур должны определять этот метод похожим способом:
  </p>
  <p>
    <pre>
      <code>
func (obj *square) accept(v visitor){
    v.visitForSquare(obj)
}
      </code>
    </pre>
  </p>
  <p>
    Погодите, разве я не заявлял чуть ранее, что не хочу менять существующие структуры фигур?
    К сожалению, во время использования паттерна Посетителя нам придется вносить изменения в структуры, но лишь единожды.
  </p>
  <p>
    В случае добавления другого функционала, например <code>getNumSides</code> или <code>getMiddleCoordinates</code>,
    мы будем использовать все тот же метод <code>accept(v visitor)</code> без новых изменений структур фигур.
  </p>
  <p>
    В конечном итоге, структуры нужно изменить лишь единожды, и все будущие запросы нового функционала можно будет реализовать с помощью функции <code>accept(v visitor)</code>.
    Если команда запросит поведение <code>getArea</code>, мы можем просто определить явную реализацию интерфейса посетителя и прописать логику вычисления площади в этой конкретной имплементации.
  </p>
